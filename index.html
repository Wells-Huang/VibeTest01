<!doctype html>

<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <title>Tree with Fruits (p5.js) — Fixed</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body { margin:0; padding:0; overflow:hidden; background:#f2efe8; }
    canvas { display:block; }
  </style>
</head>
<body>
  <!-- p5.js CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>

  <script>
  // small runtime logs to help debugging
  console.log('script loaded');

  // Global fruit particles array
  let globalFruitParticles = [];

  function Fruit(size, index, colors, branchPos) {
    this.size = size;
    this.index = index;
    this.matureChance = random(1);
    this.isMature = false;
    this.hidden = false;
    this.maturityCounter = 0;
    this.sprite = SpriteFactory.createFruitSprite(size, colors);
    this.branchPos = branchPos || {x:0,y:0};
  }

  function SpriteFactory() { /* static-only container */ }

  // static-like arrays (initialized outside class to avoid newer syntax)
  SpriteFactory.leafSprites = [];
  SpriteFactory.flowerSprites = [];

  SpriteFactory.initializeSprites = function() {
    try {
      SpriteFactory.leafSprites = [];
      SpriteFactory.flowerSprites = [];

      let leafCount = floor(random(10, 15));
      for (let i = 0; i < leafCount; i++) {
        let size = random(30, 60);
        let sprite = createGraphics(size * 2, size * 2);
        sprite.colorMode(HSB, 360, 100, 100, 1);
        sprite.noStroke();
        let clrHue = random(80, 140); // greenish
        let clrSat = random(30, 70);
        let clrBri = random(40, 80);
        let clrA = random(0.2, 1);

        sprite.drawingContext.shadowColor = 'rgba(0,0,0,0.12)';
        sprite.drawingContext.shadowBlur = 10;

        sprite.fill(clrHue, clrSat, clrBri, clrA);
        sprite.beginShape();
        sprite.vertex(size, size * 0.75);
        sprite.bezierVertex(size * 0.8, size * 0.4, size * 0.6, size * 0.1, size, 0);
        sprite.bezierVertex(size * 1.4, size * 0.1, size * 1.2, size * 0.4, size, size * 0.75);
        sprite.endShape(CLOSE);

        sprite.stroke(clrHue, max(0, clrSat - 20), max(0, clrBri - 20), 0.6);
        sprite.strokeWeight(0.5);
        sprite.line(size, size * 0.75, size, size * 0.1);
        sprite.line(size, size * 0.6, size * 0.8, size * 0.4);
        sprite.line(size, size * 0.6, size * 1.2, size * 0.4);
        sprite.line(size, size * 0.75, size * 0.9, size * 0.5);
        sprite.line(size, size * 0.75, size * 1.1, size * 0.5);

        sprite.colorMode(RGB, 255);
        SpriteFactory.leafSprites.push({ sprite: sprite, color: [clrHue, clrSat, clrBri, clrA] });
      }

      let flowerCount = floor(random(6, 8));
      for (let i = 0; i < flowerCount; i++) {
        let petalSize = random(10, 15);
        let petalNum = floor(random(5, 8));
        let sprite = createGraphics(petalSize * 3, petalSize * 3);
        sprite.colorMode(HSB, 360, 100, 100, 1);
        sprite.noStroke();
        let baseHue = random(0, 40);
        let baseSat = random(60, 80);
        let baseBri = random(70, 90);
        sprite.fill(baseHue, baseSat, baseBri);
        for (let j = 0; j < petalNum; j++) {
          sprite.push();
          sprite.translate(petalSize * 1.5, petalSize * 1.5);
          sprite.rotate(TWO_PI / petalNum * j);
          sprite.ellipse(petalSize / 2, 0, petalSize, petalSize * 0.6);
          sprite.pop();
        }
        sprite.fill((baseHue + 20) % 360, 80, random(80, 100));
        sprite.ellipse(petalSize * 1.5, petalSize * 1.5, petalSize * 0.4, petalSize * 0.4);
        sprite.colorMode(RGB, 255);
        SpriteFactory.flowerSprites.push({ sprite: sprite, petalSize: petalSize });
      }

      console.log('SpriteFactory initialized:', SpriteFactory.leafSprites.length, 'leaves,', SpriteFactory.flowerSprites.length, 'flowers');
    } catch (e) {
      console.error('SpriteFactory.initializeSprites error', e);
    }
  };

  SpriteFactory.createFruitSprite = function(size, colors) {
    try {
      let sprite = createGraphics(size * 2, size * 2);
      sprite.colorMode(RGB, 255);
      sprite.noStroke();
      let fr = constrain(floor(colors.fruit[0]), 0, 255);
      let fg = constrain(floor(colors.fruit[1]), 0, 255);
      let fb = constrain(floor(colors.fruit[2]), 0, 255);
      sprite.fill(fr, fg, fb);
      sprite.ellipse(size, size, size, size);
      return sprite;
    } catch (e) {
      console.error('createFruitSprite error', e);
      // fallback simple sprite
      let s = createGraphics(size*2, size*2);
      s.noStroke();
      s.fill(200,80,80);
      s.ellipse(size,size,size,size);
      return s;
    }
  };

  SpriteFactory.getRandomLeafSprite = function() {
    return random(SpriteFactory.leafSprites);
  };

  SpriteFactory.getRandomFlowerSprite = function() {
    return random(SpriteFactory.flowerSprites);
  };

// ---------- 替換這個整段：Tree 建構子（從 function Tree(x, y) 開始到最後一個 initialize() 呼叫結束） ----------
function Tree(x, y) {
  this.config = {
    axiom: "F",
    sentence: "F",
    generation: 0,
    maxGenerations: 4,
    windAngle: 0,
    posX: x,
    posY: y,
    growFactor: 1,
    windSpeed: 0.005,
    windStrength: 0.05,
    branchMinLength: 70,
    branchShrink: 0.7,
    branchAngleMin: 10,
    branchAngleMax: 55,
    // 調整成櫻花樹風格：更多花、比較多但小顆的果實（櫻桃）
    flowerChance: 0.35,     // 櫻花很多
    fruitChance: 0.12,      // 櫻桃比原本多一點
    fruitSizeMin: 8,        // 櫻桃偏小
    fruitSizeMax: 16,
    leafSize: 8
  };
  // 櫻桃樹偏深棕的樹幹顏色；fruit 用接近櫻桃的紅
  this.colors = {
    branch: [80, 45, 25], // RGB-style triplet used by drawing calls
    fruit: [220 + random(-20, 10), 25 + random(-10, 40), 45 + random(-20, 30)]
  };
  this.decorations = { flowers: [], fruits: [], leafSprites: [] };
  this.rules = [
    { a: "F", b: "F[+FF][-FF]F[+F][-F]", prob: 0.3 },
    { a: "F", b: "FF[+F][-F][+FF][-FF]", prob: 0.25 },
    { a: "F", b: "F[++F][--F]F[++F][--F]", prob: 0.2 },
    { a: "F", b: "FF[+F-F][-F+F]F", prob: 0.15 },
    { a: "F", b: "F[+FF][-FF][+++F][---F]", prob: 0.1 }
  ];
  this.branchData = [];
  this.branchLayer = createGraphics(windowWidth, windowHeight);
  this.leafLayer = createGraphics(windowWidth, windowHeight);
  this.initialize();
}
// ---------- 替換結束 ----------


  Tree.prototype.initialize = function() {
    this.config.sentence = this.config.axiom;
    this.config.generation = 0;
    this.decorations.flowers = [];
    this.decorations.fruits = [];
    this.decorations.leafSprites = [];
    this.branchData = [];
    for (let i = 0; i < this.config.maxGenerations; i++) {
      this.generate();
    }
    this.precomputeDecorations();
    console.log('Tree generated: sentence length', this.config.sentence.length);
  };

  Tree.prototype.generate = function() {
    let nextSentence = "";
    let branchIndex = 0;
    for (let i = 0; i < this.config.sentence.length; i++) {
      let current = this.config.sentence.charAt(i);
      if (current === "F") {
        let r = random(1);
        let cumulativeProb = 0;
        for (let rule of this.rules) {
          cumulativeProb += rule.prob;
          if (r <= cumulativeProb) {
            let newBranchString = rule.b;
            for (let char of newBranchString) {
              if (char === "F") {
                let baseLen = this.config.branchMinLength * pow(this.config.branchShrink, this.config.generation);
                let len = baseLen * (0.8 + noise(branchIndex) * 0.4);
                let angle = radians(map(random(random()), 0, 1, this.config.branchAngleMin, this.config.branchAngleMax));
                this.branchData.push({ len: len, angle: angle });
                branchIndex++;
              }
            }
            nextSentence += newBranchString;
            break;
          }
        }
      } else {
        nextSentence += current;
      }
    }
    this.config.sentence = nextSentence;
    this.config.generation++;
  };

  Tree.prototype.precomputeDecorations = function() {
    for (let i = 0; i < this.config.sentence.length; i++) {
      let current = this.config.sentence.charAt(i);
      if (current === "F") {
        if (random(1) < this.config.flowerChance && SpriteFactory.flowerSprites.length>0) {
          let flowerData = SpriteFactory.getRandomFlowerSprite();
          this.decorations.flowers.push({ sprite: flowerData.sprite, index: i, petalSize: flowerData.petalSize });
        }
        if (random(1) < this.config.fruitChance) {
          let size = random(this.config.fruitSizeMin, this.config.fruitSizeMax);
          this.decorations.fruits.push(new Fruit(size, i, this.colors, {x:0,y:0}));
        }
        let nextChar = i + 1 < this.config.sentence.length ? this.config.sentence.charAt(i + 1) : null;
        if (nextChar !== "[" && nextChar !== "F" && nextChar !== "+" && nextChar !== "-") {
          let leafCount = floor(random(1, 4));
          let leafSprites = [];
          for (let j = 0; j < leafCount; j++) {
            let angle = random(-PI/2, PI/2);
            if (SpriteFactory.leafSprites.length>0) {
              let spriteData = SpriteFactory.getRandomLeafSprite();
              leafSprites.push({ sprite: spriteData.sprite, angle: angle, color: spriteData.color });
            }
          }
          this.decorations.leafSprites.push({ index: i, sprites: leafSprites });
        }
      }
    }
  };

  Tree.prototype.getRealPos = function(x, y) {
    const point = { x: x, y: y };
    const ctx = this.branchLayer.drawingContext;
    const matrix = ctx.getTransform();
    return {
      x: matrix.a * point.x + matrix.c * point.y + matrix.e,
      y: matrix.b * point.x + matrix.d * point.y + matrix.f,
    };
  };

  Tree.prototype.draw = function() {
    this.config.windAngle = noise(frameCount * this.config.windSpeed + this.config.posX) * this.config.windStrength;
    this.branchLayer.clear();
    this.leafLayer.clear();

    this.branchLayer.push();
    this.branchLayer.translate(this.config.posX, this.config.posY);
    this.drawBranches();
    this.branchLayer.pop();

    this.leafLayer.push();
    this.leafLayer.translate(this.config.posX, this.config.posY);
    this.drawDecorations();
    this.leafLayer.pop();
  };

  Tree.prototype.drawBranches = function() {
    // stroke expects 0-255 values; ensure we pass numbers
    let bcol = this.colors.branch;
    this.branchLayer.stroke(bcol[0], bcol[1], bcol[2]);
    this.branchLayer.strokeCap(ROUND);

    let branchCounter = 0;
    let stackDepth = 0;
    const swayFactor = frameCount * 0.05;
    const windFactor = this.config.windAngle;

    for (let i = 0; i < this.config.sentence.length; i++) {
      let current = this.config.sentence.charAt(i);
      if (current === "F") {
        let branch = this.branchData[branchCounter] || { len: 150, angle: radians(20) };
        let currentLen = branch.len * this.config.growFactor;
        let sway = sin(swayFactor + i) * windFactor * map(currentLen, 0, 300, 0.5, 0.1);

        let branchWidth = map(stackDepth, 0, this.config.maxGenerations, 8, 1);
        this.branchLayer.strokeWeight(branchWidth);
        this.branchLayer.line(0, 0, 0, -currentLen);
        this.branchLayer.translate(0, -currentLen);
        this.branchLayer.rotate(sway);
        branchCounter++;
      } else if (current === "+") {
        let branch = this.branchData[branchCounter - 1] || { angle: radians(20) };
        this.branchLayer.rotate(branch.angle + windFactor * 0.5);
      } else if (current === "-") {
        let branch = this.branchData[branchCounter - 1] || { angle: radians(20) };
        this.branchLayer.rotate(-branch.angle - windFactor * 0.5);
      } else if (current === "[") {
        this.branchLayer.push();
        stackDepth++;
      } else if (current === "]") {
        this.branchLayer.pop();
        stackDepth--;
      }
    }
  };

  Tree.prototype.drawDecorations = function() {
    let flowerIndex = 0;
    let fruitIndex = 0;
    let leafIndex = 0;
    let branchCounter = 0;
    let stackDepth = 0;
    const swayFactor = frameCount * 0.05;
    const windFactor = this.config.windAngle;

    this.leafLayer.imageMode(CENTER);

    for (let i = 0; i < this.config.sentence.length; i++) {
      let current = this.config.sentence.charAt(i);
      if (current === "F") {
        let branch = this.branchData[branchCounter] || { len: 150, angle: radians(20) };
        let currentLen = branch.len * this.config.growFactor;
        let sway = sin(swayFactor + i) * windFactor * map(currentLen, 0, 300, 0.5, 0.1);

        this.leafLayer.translate(0, -currentLen);
        this.leafLayer.rotate(sway);

        if (leafIndex < this.decorations.leafSprites.length && i === this.decorations.leafSprites[leafIndex].index) {
          if (this.config.growFactor > 0.2) {
            this.drawLeafSprites(leafIndex, branch.angle);
            leafIndex++;
          }
        }

        if (flowerIndex < this.decorations.flowers.length && i === this.decorations.flowers[flowerIndex].index) {
          if (this.config.growFactor > 0.1) {
            this.drawFlowerSprite(flowerIndex, i);
            flowerIndex++;
          }
        }

        if (fruitIndex < this.decorations.fruits.length && i === this.decorations.fruits[fruitIndex].index) {
          if (this.config.growFactor > 0.3 && !this.decorations.fruits[fruitIndex].hidden) {
            let fruit = this.decorations.fruits[fruitIndex];
            fruit.branchPos = this.getRealPos(0, 0);
            this.drawFruitSprite(fruitIndex, i);
            this.checkFruitMaturity(fruitIndex);
            fruitIndex++;
          }
        }
        branchCounter++;
      } else if (current === "+") {
        let branch = this.branchData[branchCounter - 1] || { angle: radians(20) };
        this.leafLayer.rotate(branch.angle + windFactor * 0.5);
      } else if (current === "-") {
        let branch = this.branchData[branchCounter - 1] || { angle: radians(20) };
        this.leafLayer.rotate(-branch.angle - windFactor * 0.5);
      } else if (current === "[") {
        this.leafLayer.push();
        stackDepth++;
      } else if (current === "]") {
        this.leafLayer.pop();
        stackDepth--;
      }
    }
  };

  Tree.prototype.drawLeafSprites = function(index, branchAngle) {
    let leafData = this.decorations.leafSprites[index];
    if (!leafData) return;
    let leafSwayX = sin(frameCount * 0.1 + index) * 0.05;

    this.leafLayer.push();
    for (let leaf of leafData.sprites) {
      this.leafLayer.push();
      this.leafLayer.rotate(leafSwayX + branchAngle + leaf.angle);
      this.leafLayer.image(leaf.sprite, 0, -this.config.leafSize * 0.75);
      this.leafLayer.pop();
    }
    this.leafLayer.pop();
  };

  Tree.prototype.drawFlowerSprite = function(index, treeIndex) {
    let flower = this.decorations.flowers[index];
    if (!flower) return;
    let flowerSway = sin(frameCount * 0.08 + treeIndex) * 0.07;
    this.leafLayer.push();
    this.leafLayer.rotate(flowerSway);
    this.leafLayer.image(flower.sprite, 0, 0);
    this.leafLayer.pop();
  };

  Tree.prototype.drawFruitSprite = function(index, treeIndex) {
    let fruit = this.decorations.fruits[index];
    if (!fruit) return;
    let fruitSway = sin(frameCount * 0.08 + treeIndex) * 0.07;
    this.leafLayer.push();
    this.leafLayer.rotate(fruitSway);
    this.leafLayer.image(fruit.sprite, 0, 0, fruit.size * 2, fruit.size * 2);
    this.leafLayer.pop();
  };

  Tree.prototype.checkFruitMaturity = function(index) {
    let fruit = this.decorations.fruits[index];
    if (!fruit) return;
    if (!fruit.isMature && fruit.matureChance < 0.3) {
      fruit.maturityCounter++;
      if (fruit.maturityCounter > 80 && random(1) < 0.01) {
        fruit.isMature = true;
        fruit.hidden = true;
        globalFruitParticles.push({
          x: fruit.branchPos.x,
          y: fruit.branchPos.y,
          vx: random(-1.5, 1.5),
          vy: random(-2, -0.5),
          size: fruit.size,
          color: this.colors.fruit,
          sprite: fruit.sprite,
          bounceCount: 0,
          maxBounces: 2,
          life: 255
        });
      }
    }
  };

  Tree.prototype.grow = function(amount) {
    this.config.growFactor = constrain(this.config.growFactor + amount, 0, 1);
  };

  function updateAndDrawFruitParticles() {
    for (let i = globalFruitParticles.length - 1; i >= 0; i--) {
      let p = globalFruitParticles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.12;

      if (p.y + p.size / 2 > height - 50 && p.bounceCount < p.maxBounces) {
        p.y = height - 50 - p.size / 2;
        p.vy *= -0.35;
        p.vx *= 0.4;
        p.bounceCount++;
      }

      if (p.bounceCount >= p.maxBounces) {
        p.life -= 3;
      }

      push();
      tint(255, p.life);
      image(p.sprite, p.x - p.size, p.y - p.size, p.size * 2, p.size * 2);
      noTint();
      pop();

      if (p.life <= 0 || p.y > height + 200) {
        globalFruitParticles.splice(i, 1);
      }
    }
  }

  let tree;

  function setup() {
    try {
      createCanvas(windowWidth, windowHeight);
      console.log('p5 setup start');
      SpriteFactory.initializeSprites();
      tree = new Tree(width / 2, height - 10);
      noSmooth();
      console.log('p5 setup done');
    } catch (e) {
      console.error('setup error', e);
    }
  }

  function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
    if (tree) {
      tree.branchLayer = createGraphics(windowWidth, windowHeight);
      tree.leafLayer = createGraphics(windowWidth, windowHeight);
      tree.config.posX = width / 2;
      tree.config.posY = height - 10;
    }
  }

  function draw() {
    try {
      background(242, 239, 232);
      if (tree) tree.draw();
      image(tree.branchLayer, 0, 0);
      updateAndDrawFruitParticles();
      image(tree.leafLayer, 0, 0);
      fill(139, 69, 19);
      noStroke();
      rect(0, height - 50, width, 50);
    } catch (e) {
      console.error('draw error', e);
      noLoop();
    }
  }

  function mousePressed() {
    try {
      SpriteFactory.initializeSprites();
      tree = new Tree(width / 2, height - 10);
    } catch (e) {
      console.error('mousePressed error', e);
    }
  }
  </script>

</body>
</html>
