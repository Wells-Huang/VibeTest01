// Global fruit particles array
let globalFruitParticles = [];

class Fruit {
  constructor(size, index, colors, branchPos) {
    this.size = size;
    this.index = index;
    this.matureChance = random(1);
    this.isMature = false;
    this.hidden = false;
    this.maturityCounter = 0;
    this.sprite = SpriteFactory.createFruitSprite(size, colors);
    this.branchPos = branchPos; // Store initial position
  }
}

class SpriteFactory {
  static leafSprites = [];
  static flowerSprites = [];

  static initializeSprites() {
    let leafCount = floor(random(10, 15));
    for (let i = 0; i < leafCount; i++) {
      let size = random(30, 60);
      let sprite = createGraphics(size * 2, size * 2);
      sprite.colorMode(HSB);
      sprite.noStroke();
      let clr = [random(10, 40)+60, random(30, 70), random(50, 80), random([random(0.2, 1)])] 
      sprite.fill(clr[0], clr[1], clr[2], clr[3]);
      
      sprite.drawingContext.shadowColor = color(0, 0, 0, 40);
      sprite.drawingContext.shadowBlur = 20;

      sprite.beginShape();
      sprite.vertex(size, size * 0.75);
      sprite.bezierVertex(size * 0.8, size * 0.4, size * 0.6, size * 0.1, size, 0);
      sprite.bezierVertex(size * 1.4, size * 0.1, size * 1.2, size * 0.4, size, size * 0.75);
      sprite.endShape(CLOSE);

      sprite.stroke(clr[0], clr[1], clr[2] - 20, 0.8);
      sprite.strokeWeight(0.5);
      sprite.line(size, size * 0.75, size, size * 0.1);
      sprite.line(size, size * 0.6, size * 0.8, size * 0.4);
      sprite.line(size, size * 0.6, size * 1.2, size * 0.4);
      sprite.line(size, size * 0.75, size * 0.9, size * 0.5);
      sprite.line(size, size * 0.75, size * 1.1, size * 0.5);

      sprite.colorMode(RGB);
      this.leafSprites.push({ sprite, color: clr });
    }

    let flowerCount = floor(random(6, 8));
    for (let i = 0; i < flowerCount; i++) {
      let petalSize = random(10, 15);
      let petalNum = floor(random(5, 8));
      let sprite = createGraphics(petalSize * 3, petalSize * 3);
      sprite.colorMode(HSB);
      sprite.noStroke();
      let baseHue = random(0, 30);
      sprite.fill(baseHue, random(60, 80), random(70, 90));
      for (let j = 0; j < petalNum; j++) {
        sprite.push();
        sprite.translate(petalSize * 1.5, petalSize * 1.5);
        sprite.rotate(TWO_PI / petalNum * j);
        sprite.ellipse(petalSize / 2, 0, petalSize, petalSize * 0.6);
        sprite.pop();
      }
      sprite.fill((baseHue + 20) % 360, 80, random(80, 100));
      sprite.ellipse(petalSize * 1.5, petalSize * 1.5, petalSize * 0.4, petalSize * 0.4);
      sprite.colorMode(RGB);
      this.flowerSprites.push({ sprite, petalSize });
    }
  }

  static createFruitSprite(size, colors) {
    let sprite = createGraphics(size * 2, size * 2);
    sprite.noStroke();
    sprite.fill(colors.fruit[0], colors.fruit[1], colors.fruit[2]);
    sprite.ellipse(size, size, size, size);
    return sprite;
  }

  static getRandomLeafSprite() {
    return random(this.leafSprites);
  }

  static getRandomFlowerSprite() {
    return random(this.flowerSprites);
  }
}

class Tree {
  constructor(x, y) {
    this.config = {
      axiom: "F",
      sentence: "F",
      generation: 0,
      maxGenerations: 4,
      windAngle: 0,
      posX: x,
      posY: y,
      growFactor: 1,
      windSpeed: 0.005,
      windStrength: 0.05,
      branchMinLength: 70,
      branchShrink: 0.7,
      branchAngleMin: 10,
      branchAngleMax: 55,
      flowerChance: 0.08,
      fruitChance: 0.01,
      fruitSizeMin: 22,
      fruitSizeMax: 30,
      leafSize: 10
    };
    this.colors = {
      branch: [random(100, 139), random(50, 69), random(10, 19)],
      fruit: [random(150, 255), random(50, 150), random(0, 100)]
    };
    this.decorations = {
      flowers: [],
      fruits: [],
      leafSprites: []
    };
    this.rules = [
			{ a: "F", b: "F[+FF][-FF]F[+F][-F]", prob: 0.3 },
      { a: "F", b: "FF[+F][-F][+FF][-FF]", prob: 0.25 },
      { a: "F", b: "F[++F][--F]F[++F][--F]", prob: 0.2 },
      { a: "F", b: "FF[+F-F][-F+F]F", prob: 0.15 },
      { a: "F", b: "F[+FF][-FF][+++F][---F]", prob: 0.1 }
			// { a: "F", b: "F[+FF][-FF]F[+F][-F]", prob: 0.3 },
			// { a: "F", b: "FF[+F][-F][+FF][-FF]", prob: 0.25 },
			// { a: "F", b: "F[++F][--F]F[+F][-F]", prob: 0.2 },
			// { a: "F", b: "FF[+F-F][-F+F]F", prob: 0.15 },
			// { a: "F", b: "F[+FF][-FF][++F][--F]", prob: 0.1 },
			// { a: "F", b: "F[+F]F[-F]F", prob: 0.15 },
			// { a: "F", b: "FF[++F][-F][+F]", prob: 0.12 },
			// { a: "F", b: "F[-FF][+FF]F", prob: 0.13 },
			// { a: "F", b: "F[+F][-F]FF", prob: 0.10 },
			// { a: "F", b: "FF[--F][++F]F", prob: 0.11 },
			// { a: "F", b: "F[+FF][-F][+F]F", prob: 0.09 },
			// { a: "F", b: "F[-F][+F][-FF]FF", prob: 0.08 },
			// { a: "F", b: "FF[+F-F][--F]F", prob: 0.07 },
			// { a: "F", b: "F[++FF][--F][-F]F", prob: 0.06 },
			// { a: "F", b: "F[+F][-FF][++F][-F]", prob: 0.09 }
		];
    this.branchData = [];
    this.branchLayer = createGraphics(width, height);
    this.leafLayer = createGraphics(width, height);
    this.initialize();
  }

  initialize() {
    this.config.sentence = this.config.axiom;
    this.config.generation = 0;
    this.decorations.flowers = [];
    this.decorations.fruits = [];
    this.decorations.leafSprites = [];
    this.branchData = [];
    for (let i = 0; i < this.config.maxGenerations; i++) {
      this.generate();
    }
    this.precomputeDecorations();
  }

  generate() {
    let nextSentence = "";
    let branchIndex = 0;

    for (let i = 0; i < this.config.sentence.length; i++) {
      let current = this.config.sentence.charAt(i);
      if (current === "F") {
        let r = random(1);
        let cumulativeProb = 0;
        for (let rule of this.rules) {
          cumulativeProb += rule.prob;
          if (r <= cumulativeProb) {
            let newBranchString = rule.b;
            for (let char of newBranchString) {
              if (char === "F") {
                let baseLen = this.config.branchMinLength * pow(this.config.branchShrink, this.config.generation);
                let len = baseLen * (0.8 + noise(branchIndex) * 0.4);
                let angle = radians(map(random(random()),0,1,this.config.branchAngleMin, this.config.branchAngleMax));
                this.branchData.push({ len, angle });
                branchIndex++;
              }
            }
            nextSentence += newBranchString;
            break;
          }
        }
      } else {
        nextSentence += current;
      }
    }
    this.config.sentence = nextSentence;
    this.config.generation++;
  }

  precomputeDecorations() {
    for (let i = 0; i < this.config.sentence.length; i++) {
      let current = this.config.sentence.charAt(i);
      if (current === "F") {
        if (random(1) < this.config.flowerChance) {
          let flowerData = SpriteFactory.getRandomFlowerSprite();
          this.decorations.flowers.push({ 
            sprite: flowerData.sprite, 
            index: i,
            petalSize: flowerData.petalSize
          });
        }
        if (random(1) < this.config.fruitChance) {
          let size = random(this.config.fruitSizeMin, this.config.fruitSizeMax);
          this.decorations.fruits.push(new Fruit(size, i, this.colors, {x: 0, y: 0}));
        }
        let nextChar = i + 1 < this.config.sentence.length ? this.config.sentence.charAt(i + 1) : null;
        if (nextChar !== "[" && nextChar !== "F" && nextChar !== "+" && nextChar !== "-") {
          let leafCount = floor(random(1, 4));
          let leafSprites = [];
          for (let j = 0; j < leafCount; j++) {
            let angle = random(-PI/2, PI/2);
            let spriteData = SpriteFactory.getRandomLeafSprite();
            leafSprites.push({ sprite: spriteData.sprite, angle, color: spriteData.color });
          }
          this.decorations.leafSprites.push({
            index: i,
            sprites: leafSprites
          });
        }
      }
    }
  }

  getRealPos(x, y) {
    const point = { x, y };
    const ctx = this.branchLayer.drawingContext;
    const matrix = ctx.getTransform();
    return {
      x: matrix.a * point.x + matrix.c * point.y + matrix.e,
      y: matrix.b * point.x + matrix.d * point.y + matrix.f,
    };
  }

  draw() {
    this.config.windAngle = noise(frameCount * this.config.windSpeed + this.config.posX) * this.config.windStrength;
    
    // Clear layers
    this.branchLayer.clear();
    this.leafLayer.clear();

    // Draw branches
    this.branchLayer.push();
    this.branchLayer.translate(this.config.posX, this.config.posY);
    this.drawBranches();
    this.branchLayer.pop();

    // Draw leaves
    this.leafLayer.push();
    this.leafLayer.translate(this.config.posX, this.config.posY);
    this.drawDecorations();
    this.leafLayer.pop();
  }

  drawBranches() {
    this.branchLayer.stroke(this.colors.branch[0], this.colors.branch[1], this.colors.branch[2]);
    
    let branchCounter = 0;
    let stackDepth = 0;
    const swayFactor = frameCount * 0.05;
    const windFactor = this.config.windAngle;

    for (let i = 0; i < this.config.sentence.length; i++) {
      let current = this.config.sentence.charAt(i);
      if (current === "F") {
        let branch = this.branchData[branchCounter] || { len: 150, angle: radians(20) };
        let currentLen = branch.len * this.config.growFactor;
        let sway = sin(swayFactor + i) * windFactor * map(currentLen, 0, 300, 0.5, 0.1);
        
        let branchWidth = map(stackDepth, 0, this.config.maxGenerations, 5, 1);
        this.branchLayer.strokeWeight(branchWidth);
        this.branchLayer.line(0, 0, 0, -currentLen);
        this.branchLayer.translate(0, -currentLen);
        this.branchLayer.rotate(sway);
        branchCounter++;
      } else if (current === "+") {
        let branch = this.branchData[branchCounter - 1] || { angle: radians(20) };
        this.branchLayer.rotate(branch.angle + windFactor * 0.5);
      } else if (current === "-") {
        let branch = this.branchData[branchCounter - 1] || { angle: radians(20) };
        this.branchLayer.rotate(-branch.angle - windFactor * 0.5);
      } else if (current === "[") {
        this.branchLayer.push();
        stackDepth++;
      } else if (current === "]") {
        this.branchLayer.pop();
        stackDepth--;
      }
    }
  }

  drawDecorations() {
    let flowerIndex = 0;
    let fruitIndex = 0;
    let leafIndex = 0;
    let branchCounter = 0;
    let stackDepth = 0;
    const swayFactor = frameCount * 0.05;
    const windFactor = this.config.windAngle;

    this.leafLayer.imageMode(CENTER);

    for (let i = 0; i < this.config.sentence.length; i++) {
      let current = this.config.sentence.charAt(i);
      if (current === "F") {
        let branch = this.branchData[branchCounter] || { len: 150, angle: radians(20) };
        let currentLen = branch.len * this.config.growFactor;
        let sway = sin(swayFactor + i) * windFactor * map(currentLen, 0, 300, 0.5, 0.1);
        
        this.leafLayer.translate(0, -currentLen);
        this.leafLayer.rotate(sway);

        if (leafIndex < this.decorations.leafSprites.length && i === this.decorations.leafSprites[leafIndex].index) {
          if (this.config.growFactor > 0.8) {
            this.drawLeafSprites(leafIndex, branch.angle);
            leafIndex++;
          }
        }

        if (flowerIndex < this.decorations.flowers.length && i === this.decorations.flowers[flowerIndex].index) {
          if (this.config.growFactor > 0.6) {
            this.drawFlowerSprite(flowerIndex, i);
            flowerIndex++;
          }
        }

        if (fruitIndex < this.decorations.fruits.length && i === this.decorations.fruits[fruitIndex].index) {
          if (this.config.growFactor > 0.9 && !this.decorations.fruits[fruitIndex].hidden) {
            let fruit = this.decorations.fruits[fruitIndex];
            fruit.branchPos = this.getRealPos(0, 0); // Update position
            this.drawFruitSprite(fruitIndex, i);
            this.checkFruitMaturity(fruitIndex);
            fruitIndex++;
          }
        }
        branchCounter++;
      } else if (current === "+") {
        let branch = this.branchData[branchCounter - 1] || { angle: radians(20) };
        this.leafLayer.rotate(branch.angle + windFactor * 0.5);
      } else if (current === "-") {
        let branch = this.branchData[branchCounter - 1] || { angle: radians(20) };
        this.leafLayer.rotate(-branch.angle - windFactor * 0.5);
      } else if (current === "[") {
        this.leafLayer.push();
        stackDepth++;
      } else if (current === "]") {
        this.leafLayer.pop();
        stackDepth--;
      }
    }
  }

  drawLeafSprites(index, branchAngle) {
    let leafData = this.decorations.leafSprites[index];
    let leafSwayX = sin(frameCount * 0.1 + index) * 0.05;
    let leafSwayY = cos(frameCount * 0.12 + index) * 0.03;
    
    this.leafLayer.push();
    for (let leaf of leafData.sprites) {
      this.leafLayer.push();
      this.leafLayer.rotate(leafSwayX + branchAngle + leaf.angle);
      this.leafLayer.image(leaf.sprite, 0, -this.config.leafSize * 0.75);
      this.leafLayer.pop();
    }
    this.leafLayer.pop();
  }

  drawFlowerSprite(index, treeIndex) {
    let flower = this.decorations.flowers[index];
    let flowerSway = sin(frameCount * 0.08 + treeIndex) * 0.07;
    this.leafLayer.push();
    this.leafLayer.rotate(flowerSway);
    this.leafLayer.image(flower.sprite, -flower.petalSize * 1.5, -flower.petalSize * 1.5);
    this.leafLayer.pop();
  }

  drawFruitSprite(index, treeIndex) {
    let fruit = this.decorations.fruits[index];
    let fruitSway = sin(frameCount * 0.08 + treeIndex) * 0.07;
    this.leafLayer.push();
    this.leafLayer.rotate(fruitSway);
    this.leafLayer.image(fruit.sprite, -fruit.size, -fruit.size);
    this.leafLayer.pop();
  }

  checkFruitMaturity(index) {
    let fruit = this.decorations.fruits[index];
    if (!fruit.isMature && fruit.matureChance < 0.1) {
      fruit.maturityCounter++;
      if (fruit.maturityCounter > 100 && random(1) < 0.0001) {
				// console.log(fruit)
        fruit.isMature = true;
        fruit.hidden = true;
        
        globalFruitParticles.push({
          x: fruit.branchPos.x,
          y: fruit.branchPos.y,
          vx: random(-1, 1),
          vy: random(-1, 1),
          size: fruit.size,
          color: this.colors.fruit,
          sprite: fruit.sprite,
          bounceCount: 0,
          maxBounces: 2,
          life: 255
        });
      }
    }
  }

  grow(amount) {
    this.config.growFactor = constrain(this.config.growFactor + amount, 0, 1);
  }
}

function updateAndDrawFruitParticles() {
  for (let i = globalFruitParticles.length - 1; i >= 0; i--) {
    let p = globalFruitParticles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.1;
    
    if (p.y + p.size / 2 > height - 50 && p.bounceCount < p.maxBounces) {
      p.y = height - 50 - p.size / 2;
      p.vy *= -0.3;
      p.vx *= 0.3;
      p.bounceCount++;
    }
    
    if (p.bounceCount >= p.maxBounces) {
      p.life -= 2;
    }

    push();
    translate(p.x, p.y);
    // tint(255, p.life);
    image(p.sprite, -p.size, -p.size);
    pop();

    if (p.life <= 0 || p.y > height) {
      globalFruitParticles.splice(i, 1);
    }
  }
}

let tree;

function setup() {
  createCanvas(windowWidth, windowHeight);
  SpriteFactory.initializeSprites();
  tree = new Tree(width / 2, height); 
}

function draw() {
  background(242, 239, 232);
  
  // tree.grow(0.005);
  tree.draw();
	 
	
  
  // Draw layers in order: branches first, then leaves/decoration
  image(tree.branchLayer, 0, 0);
  updateAndDrawFruitParticles();
  image(tree.leafLayer, 0, 0);
  
  fill(139, 69, 19);
  noStroke();
  rect(0, height - 50, width, 50);
}

function mousePressed() {
  tree = new Tree(width / 2, height);
}