<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>寫實風格樹木生長動畫（p5.js）</title>
  <style>
    html,body { height:100%; margin:0; background: linear-gradient(#bfe6ff, #f6fcff); }
    #defaultCanvas0 { display:block; margin:0 auto; }
    .ui { position: fixed; left: 12px; top: 12px; background: rgba(255,255,255,0.7); padding:8px 10px; border-radius:8px; font-family: Arial, Helvetica, sans-serif; font-size:13px; }
    .ui label{display:block;margin:4px 0}
    .credits{position:fixed;right:10px;bottom:10px;font-family:Arial;font-size:12px;color:#444}
  </style>
</head>
<body>
  <div class="ui">
    <label>按空白鍵重新開始動畫</label>
    <label id="progressLabel">進度: 0%</label>
  </div>
  <div class="credits">p5.js 寫實樹木生長示例</div>

  <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>
  <script>
    // 寫實樹木生長動畫
    // 特性:
    // - 幹先向上生長
    // - 分枝逐步生成並延長
    // - 葉子在枝條完全長出後慢慢長大、顏色逐漸豐富
    // - 使用 Perlin noise 製造輕微搖晃與自然感

    let tree = null;
    let growthStartTime = 0;
    let totalDuration = 22000; // 總動畫時間 (ms)
    let canvasW, canvasH;
    let progressLabel;

    function setup() {
      canvasW = min(windowWidth, 1000);
      canvasH = min(windowHeight, 800);
      createCanvas(canvasW, canvasH);
      frameRate(60);
      progressLabel = select('#progressLabel');
      initTree();
    }

    function initTree() {
      tree = new Tree(width/2, height*0.92);
      growthStartTime = millis();
    }

    function draw() {
      backgroundGradient();
      let elapsed = millis() - growthStartTime;
      let t = constrain(elapsed / totalDuration, 0, 1);
      progressLabel.html('進度: ' + floor(t*100) + '%');

      // 輕微的風搖晃參數
      let wind = (noise(millis()*0.0006) - 0.5) * 0.8;

      push();
      translate(0, 0);
      tree.render(t, wind);
      pop();

      if (t >= 1) {
        // 完成後慢慢播放葉子呼吸或微晃
        tree.idleAnimate();
      }
    }

    function backgroundGradient() {
      // 柔和的天空背景
      for (let y = 0; y < height; y++) {
        let inter = map(y, 0, height, 0, 1);
        let c = lerpColor(color('#d8f0ff'), color('#fbfff8'), inter*0.9);
        stroke(c);
        line(0, y, width, y);
      }
    }

    class Branch {
      constructor(start, dir, length, depth) {
        this.start = start.copy();
        this.dir = dir.copy().normalize();
        this.fullLength = length; // 完整長度
        this.grownLength = 0; // 當前長度
        this.depth = depth;
        this.children = [];
        this.budTime = random(0.05, 0.35); // 在整體進度中的相對出現時間
        this.bloom = 0; // 葉子生長 0..1
        this.leafCount = floor(map(depth, 0, 6, 2, 18));
      }

      updateGrowth(globalT) {
        // 決定這個枝條應該生長到多少
        // 整體的生長會先從幹開始 (depth 0) 再到深度越高的枝條逐漸出現
        let delay = this.budTime * (1 + this.depth*0.08);
        let growthWindow = 0.9 - delay; // 伸長期長度
        if (growthWindow <= 0.02) growthWindow = 0.02;

        let localT = constrain((globalT - delay) / growthWindow, 0, 1);
        // 緩動曲線 - 使用 easeOutCubic
        let eased = 1 - pow(1 - localT, 3);
        this.grownLength = eased * this.fullLength;

        // 葉子在完成伸長後逐步長大
        if (localT > 0.95) {
          this.bloom = constrain(map(localT, 0.95, 1, 0, 1), 0, 1);
        }

        // propagate to children
        for (let c of this.children) {
          c.updateGrowth(globalT);
        }
      }

      render(wind, parentEnd) {
        // 計算終點 (依 grownLength)
        let start = this.start.copy();
        if (parentEnd) start = parentEnd.copy();
        let angleNoise = (noise((this.start.x+this.start.y+millis()*0.0004)*0.0001) - 0.5)*0.8;
        let sway = wind * (0.4/(this.depth+1));
        let end = p5.Vector.add(start, p5.Vector.mult(this.dir.copy().rotate(sway + angleNoise), this.grownLength));

        // 線條粗細依深度變細
        let baseStroke = map(this.depth, 0, 8, 14, 1.2);
        strokeWeight(baseStroke);

        // 幹、枝條顏色依深淺、質感
        let bark = color(68, 45, 30);
        let highlight = color(110, 80, 60);

        // 在畫線前先畫一微量的陰影
        push();
        stroke(30,20,18,40);
        strokeWeight(baseStroke+4);
        line(start.x+2, start.y+2, end.x+2, end.y+2);
        pop();

        // 主線 (模擬樹皮質感)
        push();
        // 畫多層線以增加質感
        for (let i=0;i<3;i++){
          let t = i/3;
          let col = lerpColor(bark, highlight, t);
          stroke(col);
          strokeWeight(baseStroke - i*1.6);
          line(start.x, start.y, end.x, end.y);
        }
        pop();

        // 如果已經完全長出，於節點處畫一些細小的節(芽)
        if (this.grownLength > this.fullLength*0.95) {
          let nodeRadius = map(this.depth,0,8,5,1);
          noStroke();
          fill(90,60,45);
          ellipse(end.x, end.y, nodeRadius, nodeRadius);
        }

        // 畫葉子 (只在枝條有一定長度時)
        if (this.bloom > 0.01 && this.depth >= 2) {
          this.drawLeaves(end);
        }

        // render children recursively; pass end as parentEnd to keep continuity
        for (let c of this.children) {
          c.render(wind, end);
        }
      }

      drawLeaves(position) {
        // 依 leafCount 分佈在枝條末端附近
        for (let i=0;i<this.leafCount;i++){
          // 隨機偏移
          let a = map(i, 0, this.leafCount-1, -PI/3, PI/3) + random(-0.2,0.2);
          let r = random(6, 18) * this.bloom * map(1/(this.depth+1), 0.05, 1, 0.2, 1);
          let px = position.x + cos(a)*r*2 + random(-8,8)*this.bloom;
          let py = position.y + sin(a)*r*2 + random(-6,6)*this.bloom;

          push();
          translate(px, py);
          rotate(a + noise(px*0.01, py*0.01, millis()*0.0005)*0.6);

          // 葉色從嫩綠到深綠有變化
          let leafHue = random(100,140);
          let green = color(30, random(110,160), 40);

          noStroke();
          // 漸層葉色（用多層橢圓製造光澤）
          for (let k=0;k<3;k++){
            let s = map(k,0,2,1,0.45);
            let alpha = map(k,0,2,180,100);
            fill(60 + k*10, 150 - k*30, 60, alpha * this.bloom);
            ellipse(0, 0, r * (1 - k*0.22), r * 0.6 * (1 - k*0.22));
          }

          pop();
        }
      }
    }

    class Tree {
      constructor(x, y) {
        this.base = createVector(x, y);
        this.trunk = null;
        this.branches = [];
        this.noiseOffset = random(1000);
        this.build();
      }

      build() {
        // 建立一個主要的幹，接著遞迴建立分支結構
        // trunk 是一個 Branch，深度 0
        let trunkDir = createVector(0, -1);
        let trunkLen = height * random(0.28, 0.40);
        this.trunk = new Branch(this.base, trunkDir, trunkLen, 0);
        this.generateChildren(this.trunk, 0);
      }

      generateChildren(parent, depth) {
        if (depth >= 7) return;
        // 每個節點產生 1 到 3 個子枝
        let count = depth < 2 ? 2 : floor(random(1,3));
        for (let i=0;i<count;i++){
          // 方向偏移：較小深度有較小角度，越高深度角度更大
          let angleRange = map(depth, 0, 7, PI/9, PI/2.2);
          let side = random() < 0.55 ? -1 : 1;
          let angle = random(angleRange*0.4, angleRange) * side + random(-0.15,0.15);
          let dir = parent.dir.copy().rotate(angle);
          let len = parent.fullLength * random(0.28, 0.65) * map(1/depth || 1, 0.15, 1, 0.5, 1);
          len = max(8, len);

          // child start will be computed from parent endpoint when rendering
          let child = new Branch(parent.start.copy(), dir, len, depth+1);
          child.budTime = parent.budTime + random(0.04, 0.16);
          parent.children.push(child);

          // 以某機率繼續建立更小的子分支
          if (random() < 0.92) {
            this.generateChildren(child, depth+1);
          }
        }
      }

      render(globalT, wind) {
        // 更新幹與每個分支的生長狀態
        this.trunk.updateGrowth(globalT);

        // 幹端點計算（僅用於child start continuity）
        // 計算 trunk 的終點（使用目前 grownLength）
        let trunkEnd = p5.Vector.add(this.trunk.start, p5.Vector.mult(this.trunk.dir, this.trunk.grownLength));
        // render trunk
        this.trunk.render(wind, null);
      }

      idleAnimate() {
        // 完成生長後讓葉微微呼吸(改變葉子大小)
        // 直接讓全樹的葉子依 noise 做輕微 scale 效果
        // (實作上葉子已使用 noise，在完成後會自然有些動作)
      }
    }

    function keyPressed() {
      if (key == ' ') {
        initTree();
      }
    }

    function windowResized() {
      // 重新排版以適應視窗
      canvasW = min(windowWidth, 1000);
      canvasH = min(windowHeight, 800);
      resizeCanvas(canvasW, canvasH);
      initTree();
    }

    // polyfill for min/max name conflict
    function min(a,b){return a<b?a:b}
    function max(a,b){return a>b?a:b}
  </script>
</body>
</html>
